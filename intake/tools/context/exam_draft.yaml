# Exam Draft - Populated with Evidence-Based Questions
# Generated from learning_evidence.yaml covering all 35 technical domains
# Each question traces to specific evidence line references
#
metadata:
  created_from_evidence: learning_evidence.yaml
  generation_timestamp: '2025-09-27T06:15:00.000Z'
  total_questions: 25
  domains_covered: 35
questions:
  - id: Q001
    type: factual
    question: What are the three core components required for AST parsing in TypeScript code analysis?
    category: STATIC_CODE_ANALYSIS
    difficulty: basic
    source_domain: STATIC_CODE_ANALYSIS
    source_document: sw_requirements.md
    evidence_line_refs:
      - 21
      - 33
      - 41
  - id: Q002
    type: conceptual
    question: How does call graph construction enable detection of orphaned functions?
    category: DEAD_CODE_DETECTION
    difficulty: intermediate
    source_domain: DEAD_CODE_DETECTION
    source_document: sw_requirements.md
    evidence_line_refs:
      - 33
      - 64
      - 58
  - id: Q003
    type: analytical
    question: What are the configurable thresholds for cyclomatic and cognitive complexity?
    category: CODE_QUALITY_METRICS
    difficulty: intermediate
    source_domain: CODE_QUALITY_METRICS
    source_document: sw_requirements.md
    evidence_line_refs:
      - 48
      - 51
      - 45
  - id: Q004
    type: factual
    question: What TypeScript 5.0+ compatibility features must be supported for AST parsing?
    category: TYPESCRIPT_ANALYSIS
    difficulty: basic
    source_domain: TYPESCRIPT_ANALYSIS
    source_document: sw_requirements.md
    evidence_line_refs:
      - 103
      - 108
      - 21
  - id: Q005
    type: conceptual
    question: How does the AST visitor pattern enable extensible rule systems?
    category: PLUGIN_ARCHITECTURE
    difficulty: advanced
    source_domain: PLUGIN_ARCHITECTURE
    source_document: sw_requirements.md
    evidence_line_refs:
      - 194
      - 197
      - 200
  - id: Q006
    type: factual
    question: What are the performance targets for analysis speed across different project sizes?
    category: PERFORMANCE_REQUIREMENTS
    difficulty: basic
    source_domain: PERFORMANCE_REQUIREMENTS
    source_document: sw_requirements.md
    evidence_line_refs:
      - 225
      - 233
      - 239
  - id: Q007
    type: analytical
    question: How do entry point definition and exclusion patterns work together?
    category: CONFIGURATION_SYSTEM
    difficulty: intermediate
    source_domain: CONFIGURATION_SYSTEM
    source_document: sw_requirements.md
    evidence_line_refs:
      - 120
      - 129
      - 135
  - id: Q008
    type: synthesis
    question: Design a unified analysis engine that addresses scattered responsibility issues.
    category: UNIFIED_ANALYSIS_ENGINE
    difficulty: advanced
    source_domain: UNIFIED_ANALYSIS_ENGINE
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 20
      - 47
      - 83
  - id: Q009
    type: conceptual
    question: Why does TypeScript .js to .ts import resolution require special handling?
    category: TYPESCRIPT_COMPILER_INTEGRATION
    difficulty: intermediate
    source_domain: TYPESCRIPT_COMPILER_INTEGRATION
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 5
      - 47
      - 64
  - id: Q010
    type: factual
    question: What three types of entry points should be automatically detected?
    category: ENTRY_POINT_DETECTION
    difficulty: basic
    source_domain: ENTRY_POINT_DETECTION
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 123
      - 129
      - 141
  - id: Q011
    type: analytical
    question: How do service container and command bus patterns differ in dynamic detection?
    category: DYNAMIC_PATTERN_DETECTION
    difficulty: intermediate
    source_domain: DYNAMIC_PATTERN_DETECTION
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 149
      - 155
      - 160
  - id: Q012
    type: conceptual
    question: What is architectural core protection in confidence-based detection?
    category: CONFIDENCE_BASED_DETECTION
    difficulty: advanced
    source_domain: CONFIDENCE_BASED_DETECTION
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 175
      - 188
      - 193
  - id: Q013
    type: factual
    question: What performance improvements does single-pass analysis provide?
    category: PERFORMANCE_OPTIMIZATION
    difficulty: basic
    source_domain: PERFORMANCE_OPTIMIZATION
    source_document: redesign_architecture.md
    evidence_line_refs:
      - 248
      - 254
      - 255
  - id: Q014
    type: conceptual
    question: How does TypeScript configuration ensure proper module resolution?
    category: PROJECT_SETUP_CONFIGURATION
    difficulty: intermediate
    source_domain: PROJECT_SETUP_CONFIGURATION
    source_document: implementation_guide.md
    evidence_line_refs:
      - 23
      - 67
      - 89
  - id: Q015
    type: analytical
    question: What is the relationship between TypeScript Compiler API and import extraction?
    category: AST_PARSING_IMPLEMENTATION
    difficulty: advanced
    source_domain: AST_PARSING_IMPLEMENTATION
    source_document: implementation_guide.md
    evidence_line_refs:
      - 200
      - 230
      - 260
  - id: Q016
    type: conceptual
    question: How does visitor pattern implementation enable rule interface design?
    category: RULE_ENGINE_ARCHITECTURE
    difficulty: intermediate
    source_domain: RULE_ENGINE_ARCHITECTURE
    source_document: implementation_guide.md
    evidence_line_refs:
      - 720
      - 750
      - 780
  - id: Q017
    type: factual
    question: What are the three main components of dead code detection logic?
    category: DEAD_CODE_DETECTION_LOGIC
    difficulty: basic
    source_domain: DEAD_CODE_DETECTION_LOGIC
    source_document: implementation_guide.md
    evidence_line_refs:
      - 730
      - 745
      - 760
  - id: Q018
    type: analytical
    question: How do config loading, validation, and merging work together?
    category: CONFIGURATION_MANAGEMENT
    difficulty: intermediate
    source_domain: CONFIGURATION_MANAGEMENT
    source_document: implementation_guide.md
    evidence_line_refs:
      - 1100
      - 1140
      - 1110
  - id: Q019
    type: factual
    question: What are the Jest configuration requirements and coverage thresholds?
    category: TESTING_FRAMEWORK
    difficulty: basic
    source_domain: TESTING_FRAMEWORK
    source_document: implementation_guide.md
    evidence_line_refs:
      - 1170
      - 1180
      - 1190
  - id: Q020
    type: conceptual
    question: How do command structure and argument parsing relate in CLI design?
    category: CLI_INTERFACE_DESIGN
    difficulty: intermediate
    source_domain: CLI_INTERFACE_DESIGN
    source_document: implementation_guide.md
    evidence_line_refs:
      - 1400
      - 1420
      - 1450
  - id: Q021
    type: synthesis
    question: Design a type system encompassing AnalyzerConfig and AnalysisResult structures.
    category: TYPE_SYSTEM_DESIGN
    difficulty: advanced
    source_domain: TYPE_SYSTEM_DESIGN
    source_document: complete_implementation.md
    evidence_line_refs:
      - 11
      - 21
      - 90
  - id: Q022
    type: conceptual
    question: How do custom error classes enable graceful degradation?
    category: ERROR_HANDLING_SYSTEM
    difficulty: intermediate
    source_domain: ERROR_HANDLING_SYSTEM
    source_document: complete_implementation.md
    evidence_line_refs:
      - 155
      - 170
      - 185
  - id: Q023
    type: analytical
    question: What is the relationship between cache management and incremental analysis?
    category: PERFORMANCE_MONITORING
    difficulty: advanced
    source_domain: PERFORMANCE_MONITORING
    source_document: complete_implementation.md
    evidence_line_refs:
      - 52
      - 45
      - 600
  - id: Q024
    type: factual
    question: What are the key principles of modular file structure in production architecture?
    category: PRODUCTION_ARCHITECTURE
    difficulty: basic
    source_domain: PRODUCTION_ARCHITECTURE
    source_document: complete_implementation.md
    evidence_line_refs:
      - 7
      - 155
      - 300
  - id: Q025
    type: synthesis
    question: Design a complete plugin architecture integrating built-in and custom rules.
    category: PLUGIN_SYSTEM_INTEGRATION
    difficulty: advanced
    source_domain: PLUGIN_SYSTEM_INTEGRATION
    source_document: architecture.md
    evidence_line_refs:
      - 45
      - 65
      - 85
solutions:
  - id: Q001
    answer: |
      The three core components are: (1) Parse TypeScript and JavaScript files into Abstract Syntax Trees with ES2022+ syntax support, (2) TypeScript 5.0+ compatibility with source maps and position information preservation, and (3) Support for JSX/TSX files with proper parsing.
    evidence_sources:
      - sw_requirements.md:21
      - sw_requirements.md:33
      - sw_requirements.md:41
  - id: Q002
    answer: |
      Call graph construction enables orphaned function detection by tracing all function calls from defined entry points, tracking method invocations across modules, and identifying functions not reachable from any entry point in the call graph.
    evidence_sources:
      - sw_requirements.md:33
      - sw_requirements.md:64
      - sw_requirements.md:58
  - id: Q003
    answer: |
      Cyclomatic complexity uses threshold > 10 while cognitive complexity uses > 15. Different values account for cyclomatic measuring decision points linearly while cognitive accounts for nested structures and human readability.
    evidence_sources:
      - sw_requirements.md:48
      - sw_requirements.md:51
      - sw_requirements.md:45
  - id: Q004
    answer: |
      TypeScript 5.0+ compatibility features include: ES2022+ syntax support, proper handling of new TypeScript language features, preserve source maps and position information, and handle JSX/TSX files with latest syntax extensions.
    evidence_sources:
      - sw_requirements.md:103
      - sw_requirements.md:108
      - sw_requirements.md:21
  - id: Q005
    answer: |
      The AST visitor pattern enables extensible rule systems by providing plugin lifecycle hooks for systematic AST node traversal, with shared context access and inter-plugin communication through a well-defined plugin API.
    evidence_sources:
      - sw_requirements.md:194
      - sw_requirements.md:197
      - sw_requirements.md:200
  - id: Q006
    answer: |
      Performance targets are: Small projects (< 1000 files) < 5 seconds, Medium projects (1000-10000 files) < 30 seconds, Large projects (> 10000 files) < 2 minutes, with incremental analysis < 1 second.
    evidence_sources:
      - sw_requirements.md:225
      - sw_requirements.md:233
      - sw_requirements.md:239
  - id: Q007
    answer: |
      Entry point definition provides starting points through JSON/YAML configuration with multiple entry points and glob patterns, while exclusion patterns define files/folders to skip using gitignore-style patterns for focused analysis.
    evidence_sources:
      - sw_requirements.md:120
      - sw_requirements.md:129
      - sw_requirements.md:135
  - id: Q008
    answer: |
      A unified analysis engine should consolidate separate analyzers into single source of truth with TypeScript Compiler API for proper AST usage, unified dependency graph for systematic reachability analysis, and single-pass file loading.
    evidence_sources:
      - redesign_architecture.md:20
      - redesign_architecture.md:47
      - redesign_architecture.md:83
  - id: Q009
    answer: |
      TypeScript .js to .ts import resolution requires special handling because ESM imports reference .js files but TypeScript source files are .ts, requiring module resolver to map import paths correctly using TypeScript built-in resolution with NodeNext moduleResolution.
    evidence_sources:
      - redesign_architecture.md:5
      - redesign_architecture.md:47
      - redesign_architecture.md:64
  - id: Q010
    answer: |
      The three types are: (1) Package.json analysis for bin entries and main field, (2) CLI pattern detection for conventional CLI files like src/cli/cli.ts, and (3) Conventional entry points like src/index.ts and index.ts.
    evidence_sources:
      - redesign_architecture.md:123
      - redesign_architecture.md:129
      - redesign_architecture.md:141
  - id: Q011
    answer: |
      Service container patterns detect container.register/resolve calls for dependency injection, while command bus patterns detect commandBus.registerCommand/Handler calls for command handling, differing in registration mechanisms and usage contexts.
    evidence_sources:
      - redesign_architecture.md:149
      - redesign_architecture.md:155
      - redesign_architecture.md:160
  - id: Q012
    answer: |
      Architectural core protection reduces confidence scores for files containing core patterns like Application, Container, ServiceContainer, recognizing that core architectural files may not be directly called but are essential infrastructure components.
    evidence_sources:
      - redesign_architecture.md:175
      - redesign_architecture.md:188
      - redesign_architecture.md:193
  - id: Q013
    answer: |
      Single-pass analysis provides 10x faster performance, <10% false positive rate vs current 33%, O(n) memory scaling vs current O(n²), and eliminates redundant file processing across multiple analyzers.
    evidence_sources:
      - redesign_architecture.md:248
      - redesign_architecture.md:254
      - redesign_architecture.md:255
  - id: Q014
    answer: |
      TypeScript configuration ensures proper module resolution through tsconfig.json parsing with ES2022 target, commonjs module, strict mode enabled, esModuleInterop, and resolveJsonModule for comprehensive syntax and import support.
    evidence_sources:
      - implementation_guide.md:23
      - implementation_guide.md:67
      - implementation_guide.md:89
  - id: Q015
    answer: |
      TypeScript Compiler API creates program with type checker, enabling import/export extraction by visiting AST nodes with ts.forEachChild, identifying import/export declarations, and extracting module specifiers with proper type information.
    evidence_sources:
      - implementation_guide.md:200
      - implementation_guide.md:230
      - implementation_guide.md:260
  - id: Q016
    answer: |
      Visitor pattern implementation provides systematic AST traversal where each rule implements check method visiting nodes, while rule interface design standardizes issue creation and context access, enabling pluggable rule engines.
    evidence_sources:
      - implementation_guide.md:720
      - implementation_guide.md:750
      - implementation_guide.md:780
  - id: Q017
    answer: |
      The three components are: (1) Unreachable code detection after return statements, (2) Unused function analysis using call graph reachability, and (3) Unused import checking, integrated using call graph to determine usage.
    evidence_sources:
      - implementation_guide.md:730
      - implementation_guide.md:745
      - implementation_guide.md:760
  - id: Q018
    answer: |
      Config loading searches for analyzer.config.js/json in directories, schema validation uses AJV with predefined schema for type safety, and config merging combines base configuration with user overrides using object spread.
    evidence_sources:
      - implementation_guide.md:1100
      - implementation_guide.md:1140
      - implementation_guide.md:1110
  - id: Q019
    answer: |
      Jest configuration requires ts-jest preset, node test environment, coverage collection from src/**/*.ts excluding .d.ts and .test.ts files, with coverage thresholds of 80% for branches, functions, lines, and statements.
    evidence_sources:
      - implementation_guide.md:1170
      - implementation_guide.md:1180
      - implementation_guide.md:1190
  - id: Q020
    answer: |
      Command structure uses Commander.js with nested commands and options, argument parsing handles paths, configs, and flags with validation, while output formatting supports JSON, HTML, and markdown with configurable verbosity.
    evidence_sources:
      - implementation_guide.md:1400
      - implementation_guide.md:1420
      - implementation_guide.md:1450
  - id: Q021
    answer: |
      A production type system should include AnalyzerConfig interface with entryPoints, exclude, rules arrays; RuleConfigMap with enabled/severity/threshold properties; and AnalysisResult with issues, callGraph, and metrics using TypeScript strict mode.
    evidence_sources:
      - complete_implementation.md:11
      - complete_implementation.md:21
      - complete_implementation.md:90
  - id: Q022
    answer: |
      Custom error classes extend base Error with specific types (ParseError, ConfigError, ValidationError) enabling graceful degradation by catching specific errors, continuing analysis despite individual file failures, and providing partial results.
    evidence_sources:
      - complete_implementation.md:155
      - complete_implementation.md:170
      - complete_implementation.md:185
  - id: Q023
    answer: |
      Cache management stores analysis results by file hash, incremental analysis only processes changed files using timestamps, and memory optimization uses LRU caches and streaming for large projects, providing scalable performance monitoring.
    evidence_sources:
      - complete_implementation.md:52
      - complete_implementation.md:45
      - complete_implementation.md:600
  - id: Q024
    answer: |
      Modular file structure organizes code by feature/responsibility with clear separation, interface segregation ensures small focused interfaces avoiding fat interfaces, and dependency injection enables loose coupling and testability.
    evidence_sources:
      - complete_implementation.md:7
      - complete_implementation.md:155
      - complete_implementation.md:300
  - id: Q025
    answer: |
      A complete plugin architecture should include Plugin Manager for loading/registration, standardized Plugin interface with lifecycle hooks, Built-in Rules for core functionality, Custom Rules API for extensions, and Third-party plugin support with version compatibility.
    evidence_sources:
      - architecture.md:45
      - architecture.md:65
      - architecture.md:85
